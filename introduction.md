# Loo.py编程系统的实现方式以及多面体模型


## 程序转换技术  

**程序转换**(Program Transformation)是指将一个计算机程序进行转换，并根据需要生成另一个程序的技术。大多数情况下，被转换的程序需要与原始程序在语义上等价，但在很少的情况下，转换导致程序在语义上也可与原始程序在可预见的方式上有所不同。一般来说，语义等价性是一种程序细化(Program Refinement)的概念：如果一个程序终止于原始程序终止的所有初始状态，且对于每个这样的状态，确保它可以在原始程序的某个可能的终止状态终止，则这个程序是原始程序的细化。换句话说，一个程序的细化比这个源程序更加明确，且如果两个程序互为对方的细化，则这两个程序是等价的。   

虽然这种转换可以是手动的人工转换，但对于更大规模的代码或者需要针对多种不同情况，使用一个程序转换系统来进行所需要的转换更加实用。程序转换可以是修改表示程序的数据结构（如抽象语法树AST）的自动程序，也可以通过使用特定模式来表示参数化源代码文本片段来指定。  

源代码转换系统通常需要整合需要转化的编程语言的完整前端，包括源代码解析，代码结构的内部程序表示的建立，程序符号的含义，有效的静态分析，以及根据转换后的程序表示重新生成的有效源代码。  

程序转换技术已广泛运用于许多软件工程领域，如程序综合，程序优化，程序重构，逆行工程，及文档生成等。本组所研究的Loo.py即为一种基于程序转换的针对GPU和CPU的代码生成工具。  


## 使用多面体模型表示程序  

**多面体模型**(Polyhedral Model)是一种基于线性代数来表示程序和程序转换的计算模型，它应用了丰富的数学理论和直观的几何解释，且作为AST的改进，适合表示串行以及并行程序，并为分析和应用程序转换提供了方便的抽象模型。在程序的自动并行化和优化的处理方面上，已经通过应用多面体模型，已经取得了巨大的成效。

大致来说，多面体模型的应用框架是传统编译过程的一个插件。对它的应用分为以下步骤：
1. 首先，从抽象语法树开始，将适合多面体模型的部分程序翻译成线性代数表示；
2. 下一步，通过使用一种重新排序函数，来选择新的代码执行顺序。如何来寻找最为适合的代码执行顺序正是大多于对于多面体模型研究的重点；
3. 最后，进行代码生成，返回原有抽象生成树，或实现根据代码重排函数指定的执行顺序的新的源代码。

多面体模型是一种既适用于串行程序，也适用于并行程序的计算模型和表示方法。它对应了命令式语言的一种被称为静态控制程序的子集，包括C, FORTRAN等语言。这些语言的性质可被大致概括为：
1. 控制语句是具有仿射边界的do循环语句和具有仿射条件的if条件语句；
2. 仿射边界和条件仅取决于外围循环计数器和常量参数。

在任何程序中，连续的具有静态控制的语句的最大集合被成为静态控制部分。下面的程序即为一个严格的静态控制程序的例子：
```FORTRAN
    do i = 1, n
S1      x = a(i,i)
        do j = 1, i - 1
S2          x = x - a(i,j) ** 2
S3      p(i) = 1.0 / sqrt(x)
        do j = i + 1, n
S4          x = a(i,j)
            do k = 1, i - 1
S5              x = x - a(j,k) * a(i,k)
S6          a(j,i) = x * p(i)
```

这类程序中的循环可以用迭代矢量——n维列向量**x**=(i<sub>1</sub>,i<sub>2</sub>,...,i<sub>n</sub>)<sup>T</sup>表示，其中i<sub>k</sub>是第k层循环的循环迭代变量（如在最外层`do i = 1, n`循环中，循环变量为i，k为1，故i<sub>k</sub>=i），n是最内层循环的层数。考虑这类静态控制集合，对于每个语句可以用两种属性来表示，以此便可以完整地描述程序的执行，这两种属性分别为：
1. 迭代域(iteration domain)，即该语句需要执行的迭代矢量的取值的集合。  
当语句在静态控制内时，其迭代域总是可以由一组定义多面体的线性不等式来指定。  
S2语句的迭代矢量为(i,j)<sup>T</sup>，故它的迭代域为由i，j在迭代中的取值范围确定的矢量空间，在外层循环中，i的取值为从1到n，内层循环中，j的取值为1到i-1。故S2语句的矢量空间为由i≥1，i≤n，j≥1和j\<i确定的域，如下图：  
![The correspondence between static control and polyhedral domains for the statement S2 of the program above](https://github.com/wwqqqqq/loopy-introduction/raw/master/pic/polyhedron.png)  


1. 散射函数(scattering function) θ(**x**)：仿射函数为迭代域中的每个整数点指定相应语句实例的新坐标。
根据上下文的不同，这里的“坐标”可以是空间上的坐标(space-mapping)，即执行这条语句的处理器号，或者时间上的坐标(time-schedule)，在这里是一个n维向量，表示该语句执行的逻辑时间(logical date)。逻辑时间为(a<sub>1</sub>...a<sub>n</sub>)的语句在对应时间为(b<sub>1</sub>...b<sub>n</sub>)的语句之前执行，当且仅当存在i，1≤i\<n，使得(a<sub>1</sub>...a<sub>i</sub>)=(b<sub>1</sub>...b<sub>i</sub>)，且a<sub>i+1</sub>\<b<sub>i+1</sub>，即不同语句的执行顺序遵循它们逻辑时间的字典序。    

这样以来，我们可以通过每个语句所处的循环嵌套情况和顺序，通过改进的AST来表示该程序的顺序执行顺序。以上面的程序为例，它的AST表示为：  
![AST of the program above, using polyhedral model](https://github.com/wwqqqqq/loopy-introduction/raw/master/pic/AST.png)  
散射函数为：  
θ<sub>S1</sub>(**x**<sub>S1</sub>)=(0,i,0)<sup>T</sup>  
θ<sub>S2</sub>(**x**<sub>S2</sub>)=(0,i,1,j,0)<sup>T</sup>  
θ<sub>S3</sub>(**x**<sub>S3</sub>)=(0,i,2)<sup>T</sup>    

使用多面体模型的程序转换可以用适当的散射函数来确定。在这种程序转换中，它们将源多面体修改为包含相同点，但使用不同坐标系的目标多面体，因此具有新的字典顺序，即新的语句执行顺序。在这里，只简单叙述如何用多面体模型表示程序，就不再对使用多面体模型的程序转换加以详述了。


## Loo.py简介

随着计算机科学的发展，应用程序的功能越来越强大，随之而来的，是需要处理的数据量、计算量的加大，和对程序运行性能的要求提升。此外，高度异构的计算环境也给如何实现在不同的机器上实现高性能程序带来了负担——同样的程序，为了在不同的机器上都能高效运行，在最坏的情况下，可能需要为每种不同计算机架构编写一种数学上等价的程序实现。

Loo.py的出现正是为了在一定程度上解决这个问题。Loo.py是一个嵌入在Python中的编程系统，它为阵列式计算定义了一个数据模型，以及运行在该数据模型上的转换库，提供了循环平铺(loop tiling)，矢量化(vectorization)，存储管理(storage management)，展开(unrolling)，指令级并行化(instruction-level parallelism)，数据布局修改(change of data layout)等转换方式，为捕获，参数化和重新统一代码变体之间的增长提供了一种便捷的方法。此外，与numpy和PyOpenCL的深度集成提供了一个便捷的计算环境，使得从原型到高性能实现的转换可以以一个渐进的、机器辅助的形式进行。

随着计算机架构和程序执行模型的多样化，表达单个计算的数学等价的方法的数量正在迅速增长，然而这些程序变体中只有极少数实现了良好的机器利用率——即峰值内存带宽或浮点吞吐量的百分比等。

无论是否有用户注释的帮助，优化编译器都等价地将用户代码重写成更高性能的变体，这是解决这个问题的标准方法，尽管为了实现良好性能的目标，编译器的内置优化过程有时会变得十分复杂。

而Loo.py则采取了不同的方法：Loo.py代码通常嵌入在高级编程语言Python的外部控制程序中。用户首先使用一种由描述循环边界的多面体树和一系列绑定到多面体树节点的指令组成的语言来指定要执行的计算。用户所提供的规范是弱有序的，以此给代码生成器提供了更多自由。用户依上所述所指定的计算，其描述就会被保存在一个对象中，该对象对于宿主语言内的检查和操作是开放的。这些操作是通过应用各种Loo.py转换库中的转换来实现的，Loo.py中的这些转换完全保留了源代码中的语义。

这种实现方式与传统编译器有着以下方面的重要区别：

- 代码的中间表示是有意开放给用户，并由用户进行检查和操作的。高级用户可以轻松实现自定义的转换，以此扩充已有的转换库。
- 指令、循环边界和转换，在一起唯一地指定要生成的代码。Loo.py不会试图自作主张地代表用户做出选择，而是同时保留一个足够高层的接口，以便开发人员/有一定技术能力的终端用户使用。
- 传统的编译器需要证明它们对源程序进行的任何重写都不会在可观察到的层面上改变程序的运行行为，这给编译器带来了很大的负担和掣肘。而显式地调用一些转换允许了更多的灵活性：通过显式调用一个转换,程序运行的正确性可以部分由用户来承担，这使得在传统编译体系中难以或不可能实现的变化可以被应用，例如全局可见数据布局的变化。
- 与传统的'pragma'-type编译器指令不同，Loo.py中的转换是在完整规模的编程语言的控制下被应用的，这意味着代码生成可以对于目标机器的硬件或者目前的工作负载的不同或变化作出反应。

此外，来自高级编程环境的控制鼓励在转换空间内的重新使用和抽象，这有助于用户处理更大规模的代码生成任务，其中，可能需要生成大量相似的计算内核。


## 参考文献

[Code Generation in the Polyhedral Model Is Easier Than You Think](https://dl.acm.org/citation.cfm?id=1025992) 

[Loo.py: transformation-based code generation for GPUs and CPUs](https://arxiv.org/abs/1405.7470)


## 相关链接

[GitHub repository](https://github.com/01-Loopy/loo.py-intro)

[项目简介、分工以及进展记录](https://github.com/01-Loopy/2017fall-student-teamworks/blob/master/01-loopy.md)