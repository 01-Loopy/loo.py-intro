# Loo.py编程系统的实现方式以及多面体模型


## 程序转换技术  

**程序转换**(Program Transformation)是指将一个计算机程序进行转换，并根据需要生成另一个程序的技术。大多数情况下，被转换的程序需要与原始程序在语义上等价，但在很少的情况下，转换导致程序在语义上也可与原始程序在可预见的方式上有所不同。一般来说，语义等价性是一种程序细化(Program Refinement)的概念：如果一个程序终止于原始程序终止的所有初始状态，且对于每个这样的状态，确保它可以在原始程序的某个可能的终止状态终止，则这个程序是原始程序的细化。换句话说，一个程序的细化比这个源程序更加明确，且如果两个程序互为对方的细化，则这两个程序是等价的。   

虽然这种转换可以是手动的人工转换，但对于更大规模的代码或者需要针对多种不同情况，使用一个程序转换系统来进行所需要的转换更加实用。程序转换可以是修改表示程序的数据结构（如抽象语法树AST）的自动程序，也可以通过使用特定模式来表示参数化源代码文本片段来指定。  

源代码转换系统通常需要整合需要转化的编程语言的完整前端，包括源代码解析，代码结构的内部程序表示的建立，程序符号的含义，有效的静态分析，以及根据转换后的程序表示重新生成的有效源代码。  

程序转换技术已广泛运用于许多软件工程领域，如程序综合，程序优化，程序重构，逆行工程，及文档生成等。本组所研究的Loo.py即为一种基于程序转换的针对GPU和CPU的代码生成工具。  


## 使用多面体模型表示程序  

**多面体模型**(Polyhedral Model)是一种基于线性代数来表示程序和程序转换的计算模型，它应用了丰富的数学理论和直观的几何解释，且作为AST的改进，适合表示串行以及并行程序，并为分析和应用程序转换提供了方便的抽象模型。在程序的自动并行化和优化的处理方面上，已经通过应用多面体模型，已经取得了巨大的成效。Loo.py的实现中，数据模型正是借鉴了多面体模型的思想，以便对代码进行深度优化。

大致来说，多面体模型的应用框架是传统编译过程的一个插件。对它的应用分为以下步骤：
1. 首先，从抽象语法树开始，将适合多面体模型的部分程序翻译成线性代数表示；
2. 下一步，通过使用一种重新排序函数，来选择新的代码执行顺序。如何来寻找最为适合的代码执行顺序正是大多于对于多面体模型研究的重点；
3. 最后，进行代码生成，返回原有抽象生成树，或实现根据代码重排函数指定的执行顺序的新的源代码。

多面体模型是一种既适用于串行程序，也适用于并行程序的计算模型和表示方法。它对应了命令式语言的一种被称为静态控制程序的子集，包括C, FORTRAN等语言。这些语言的性质可被大致概括为：
1. 控制语句是具有仿射边界的do循环语句和具有仿射条件的if条件语句；
2. 仿射边界和条件仅取决于外围循环计数器和常量参数。

在任何程序中，连续的具有静态控制的语句的最大集合被成为静态控制部分。下面的程序即为一个严格的静态控制程序的例子：
```FORTRAN
    do i = 1, n
S1      x = a(i,i)
        do j = 1, i - 1
S2          x = x - a(i,j) ** 2
S3      p(i) = 1.0 / sqrt(x)
        do j = i + 1, n
S4          x = a(i,j)
            do k = 1, i - 1
S5              x = x - a(j,k) * a(i,k)
S6          a(j,i) = x * p(i)
```

这类程序中的循环可以用迭代矢量——n维列向量**x**=(i<sub>1</sub>,i<sub>2</sub>,...,i<sub>n</sub>)<sup>T</sup>表示，其中i<sub>k</sub>是第k层循环的循环迭代变量（如在最外层`do i = 1, n`循环中，循环变量为i，k为1，故i<sub>k</sub>=i），n是最内层循环的层数。考虑这类静态控制集合，对于每个语句可以用两种属性来表示，以此便可以完整地描述程序的执行，这两种属性分别为：
1. 迭代域(iteration domain)，即该语句需要执行的迭代矢量的取值的集合。  
当语句在静态控制内时，其迭代域总是可以由一组定义多面体的线性不等式来指定。  
S2语句的迭代矢量为(i,j)<sup>T</sup>，故它的迭代域为由i，j在迭代中的取值范围确定的矢量空间，在外层循环中，i的取值为从1到n，内层循环中，j的取值为1到i-1。故S2语句的矢量空间为由i≥1，i≤n，j≥1和j\<i确定的域，如下图： 
![The correspondence between static control and polyhedral domains for the statement S2 of the program above](https://github.com/wwqqqqq/loopy-introduction/raw/master/pic/polyhedron.png)  


1. 散射函数(scattering function) θ(**x**)：仿射函数为迭代域中的每个整数点指定相应语句实例的新坐标。
根据上下文的不同，这里的“坐标”可以是空间上的坐标(space-mapping)，即执行这条语句的处理器号，或者时间上的坐标(time-schedule)，在这里是一个n维向量，表示该语句执行的逻辑时间(logical date)。逻辑时间为(a<sub>1</sub>...a<sub>n</sub>)的语句在对应时间为(b<sub>1</sub>...b<sub>n</sub>)的语句之前执行，当且仅当存在i，1≤i\<n，使得(a<sub>1</sub>...a<sub>i</sub>)=(b<sub>1</sub>...b<sub>i</sub>)，且a<sub>i+1</sub>\<b<sub>i+1</sub>，即不同语句的执行顺序遵循它们逻辑时间的字典序。    

这样以来，我们可以通过每个语句所处的循环嵌套情况和顺序，通过改进的AST来表示该程序的顺序执行顺序。以上面的程序为例，它的AST表示为：  
![AST of the program above, using polyhedral model](https://github.com/wwqqqqq/loopy-introduction/raw/master/pic/AST.png)  
散射函数为：  
θ<sub>S1</sub>(**x**<sub>S1</sub>)=(0,i,0)<sup>T</sup>  
θ<sub>S2</sub>(**x**<sub>S2</sub>)=(0,i,1,j,0)<sup>T</sup>  
θ<sub>S3</sub>(**x**<sub>S3</sub>)=(0,i,2)<sup>T</sup>    

使用多面体模型的程序转换可以用适当的散射函数来确定。在这种程序转换中，它们将源多面体修改为包含相同点，但使用不同坐标系的目标多面体，因此具有新的字典顺序，即新的语句执行顺序。在这里，只简单叙述如何用多面体模型表示程序，就不再对使用多面体模型的程序转换加以详述了。
  
  
  
**多面体模型与抽象语法树的对比**：多面体模型和抽象语法树仅在对循环及其内部结构的表式上有所差异。多面体模型对于使用迭代变量的循环作出了优化，便于分析循环的层级结构和循环执行次数的特征。

| 多面体模型 | 抽象语法树 |
| --------- | --------- |
| 内部结点是循环的迭代变量，叶结点是语句 | 内部结点是非终结符，叶结点为终结符 |
| 以迭代变量标识循环，循环内/外部变量的分析较为方便 | 按传统结构，仅分析循环体的语法结构，不关心循环条件 |
| 以循环的迭代域构造多面体，并用数学方法，完成高效的程序转换 | 程序转换相比多面体模型较为复杂 |
| 可以针对一些语法中体现不出的进行程序转换，如循环倒置(loop inversion)，循环平铺(loop tiling)等 | 只能从语法的角度对程序进行分析优化，不适合用于对复杂程序进行结构重构 |



## Loo.py简介

随着计算机科学的发展，应用程序的功能越来越强大，随之而来的，是需要处理的数据量、计算量的加大，和对程序运行性能的要求提升。此外，高度异构的计算环境也给如何实现在不同的机器上实现高性能程序带来了负担——同样的程序，为了在不同的机器上都能高效运行，在最坏的情况下，可能需要为每种不同计算机架构编写一种数学上等价的程序实现。

Loo.py的出现正是为了在一定程度上解决这个问题。Loo.py是一个嵌入在Python中的编程系统，它为阵列式计算定义了一个数据模型，以及运行在该数据模型上的转换库，提供了循环平铺(loop tiling)，矢量化(vectorization)，存储管理(storage management)，展开(unrolling)，指令级并行化(instruction-level parallelism)，数据布局修改(change of data layout)等转换方式，为捕获，参数化和重新统一代码变体之间的增长提供了一种便捷的方法。此外，与numpy和PyOpenCL的深度集成提供了一个便捷的计算环境，使得从原型到高性能实现的转换可以以一个渐进的、机器辅助的形式进行。

随着计算机架构和程序执行模型的多样化，表达单个计算的数学等价的方法的数量正在迅速增长，然而这些程序变体中只有极少数实现了良好的机器利用率——即峰值内存带宽或浮点吞吐量的百分比等。

无论是否有用户注释的帮助，优化编译器都等价地将用户代码重写成更高性能的变体，这是解决这个问题的标准方法，尽管为了实现良好性能的目标，编译器的内置优化过程有时会变得十分复杂。

而Loo.py则采取了不同的方法：Loo.py代码通常嵌入在高级编程语言Python的外部控制程序中。用户首先使用一种由描述循环边界的多面体树和一系列绑定到多面体树节点的指令组成的语言来指定要执行的计算。用户所提供的规范是弱有序的，以此给代码生成器提供了更多自由。用户依上所述所指定的计算，其描述就会被保存在一个对象中，该对象对于宿主语言内的检查和操作是开放的。这些操作是通过应用各种Loo.py转换库中的转换来实现的，Loo.py中的这些转换完全保留了源代码中的语义。

这种实现方式与传统编译器有着以下方面的重要区别：

- 代码的中间表示是有意开放给用户，并由用户进行检查和操作的。高级用户可以轻松实现自定义的转换，以此扩充已有的转换库。
- 指令、循环边界和转换，在一起唯一地指定要生成的代码。Loo.py不会试图自作主张地代表用户做出选择，而是同时保留一个足够高层的接口，以便开发人员/有一定技术能力的终端用户使用。
- 传统的编译器需要证明它们对源程序进行的任何重写都不会在可观察到的层面上改变程序的运行行为，这给编译器带来了很大的负担和掣肘。而显式地调用一些转换允许了更多的灵活性：通过显式调用一个转换，程序运行的正确性可以部分由用户来承担，这使得在传统编译体系中难以或不可能实现的变化可以被应用，例如全局可见数据布局的变化。
- 与传统的'pragma'-type编译器指令不同，Loo.py中的转换是在完整规模的编程语言的控制下被应用的，这意味着代码生成可以对于目标机器的硬件或者目前的工作负载的不同或变化作出反应。

此外，来自高级编程环境的控制鼓励在转换空间内的重新使用和抽象，这有助于用户处理更大规模的代码生成任务，其中，可能需要生成大量相似的计算内核。


## Loo.py的工作方式 

### Loo.py的数据模型 
以一个简单的例子进行说明：  
*注：下面的程序是使用isl库的语法进行编写的，isl是一种多面体模型的整数集上的库，具体语法见*[*isl: An integer set library for the polyhedral model.*](https://link.springer.com/chapter/10.1007/978-3-642-15582-6_49)
```Python
knl = loopy.make_kernel(
        "{ [i]: 0<=i<n }", #loop domain
        "out[i] = 2*a[i]"  #instructions
)
```
通过上面的程序，可以看出，Loo.py内核(Loo.py kernel)包含两个主要的组成部分：循环域和指令。  

1. 循环域(loop domain)在这里是`{[i]: 0<=i<n}`。它定义了将要执行指令的整型循环变量值。在Loo.py中，将这种循环变量称为iname。如若在上文所示程序的循环中`{ [i]: 0<=i<n }`，'i'是唯一的iname。循环域由仿射等式/不等式给出。这里的i的循环域为[0,n)上的所有整数，但整数可分割型约束也是允许的。在没有可分型约束的情况下，循环域是凸集。  
在这个例子中，n是一个用户给出的参数而不是iname，它决定了需要操作的向量a和out的长度。Loo.py允许用户给出关于参数的其他信息来帮助生成更高质量的代码。如在上述程序中，若用户已知n是一个可以被4整除的正数，用户可以在程序中添加假设(assumption)：`assuptions="n > 0 and n mod 4 = 0"`。假设同样是使用isl语法编写的。  
实际上，大多数程序中，为了适应一些依赖于数据的控制流，Loo.py使用循环域树或森林来对程序中的循环进行表示，见上文中对于多面体模型中AST的解释。这允许了更深层嵌套的循环域，可以依赖于较为上层的循环域的iname。
2. 指令：`out[i] = 2*a[i]`。  
指令是数组元素之间的标量赋值，由一个左值和等号右侧的表达式组成。表达式包括常用数学运算符，也可以调用OpenCL中定义的，或用户自定义的函数(Loo.py为用户自定义函数、符号、操作符提供编程接口)。

### 运行Loo.py内核
使用Loo.py的宿主语言Python来运行上文例中所定义的Loo.py内核knl：  
```Python
eve, (out,) = knl(queue, a=x_vec_dev)
assert (out.get() == (2*x_vec_dev).get()).all()
```
这个运行时功能使用PyOpenCL。`queue`是一个PyOpenCL中定义的对象`CommandQueue`，对应了一个OpenCL设备数组(device array)——一个驻留在OpenCL全局设备内存中的numpy数组的工作类。PyOpenCL的设备数组，与numpy数组相似，包括类型、形状和内存布局信息。`assert`语句将数据传回给主机，传到新建立的numpy数组中，并检查计算结果是否正确。  
Loo.py使用运行时类型`x_vec_dev`来专门化内核。在没有其他信息的情况下，基于对`out`的单一赋值，类型推断可以判断出`out`是与输入数组`a`相同的单精度浮点数数组。此外，由于Loo.py可以通过数组`a`的数组长度自行得到n的大小，所以参数`n`实际上是不需要传递给内核的。

### 指令排序
```Python
knl = loopy.make_kernel(
        "{ [i,j,ii,jj]: 0<=i,j,ii,jj<n }",
        """
        out[j,i] = a[i,j] {id=transpose}
        out[ii,jj] = 2*out[ii,jj] {dep=transpose}
        """
)
```
以上代码首先计算一个二维数组的转置，然后将每个条目加倍（作为一个单独的操作）。


值得注意的是，Loo.py的编程模型在默认情况下是完全无序的，这意味着：  
- 循环域遍历的顺序执行(或并发执行)是没有保证的。如在上面的内核中，i=3可以在i=0之前就遍历得到，也可以与i=17并行完成。仅当一个程序产生有效结果时，才称这个程序是格式良好的，而不管其中的循环执行顺序如何。
- 指令之间是无序的。指令之间的排序可以通过显式确定的依赖关系来指定。
- 循环域所隐含的循环嵌套顺序是未定义的。

所请求的循环嵌套顺序可以以优先级列表的形式被指定，优先级列表的语义被定义如下：  
**Rule 1** (循环嵌套和优先级)  
如果在确定循环嵌套期间存在不明确性(即，可以在不影响程序语义的情况下打开有多个iname的循环)时，iname优先级列表中出现较早的iname优先级较高。  

注：优先级列表所指定的优先级信息只有参考作用。若内核在逻辑上需要与优先级列表所指定的不同的嵌套，应忽略此处的优先级。只有循环嵌套不明确时，才考虑优先级的使用。  

为了确定指令间的和循环间的顺序，Loo.py需要遵循如下规则：  
**Rule 2** (依赖关系)  
若指令B依赖于指令A，则在A和B的iname集的最大共享集合上，A在B之前被执行。

在上面的内核中：   
1. 通过显式地给一个指令一个符号名(`{id=name}`)，然后在另一条指令的依赖列表中引用该符号名(`{dep=name}`)，来以此声明了依赖关系：加倍指令依赖于转置指令。
2. 加倍操作使用一组单独的循环变量ii和jj。若加倍操作同样使用了i和j，则依赖关系仅会在它们共享的i/j循环中被应用。

由于手动记录依赖关系较为复杂，Loo.py额外地应用了如下启发式：  
**Rule 3** (依赖启发式)  
如果一个变量只用一条指令写入，则所有读取该变量的指令都自动地依赖那条写入指令。

这种启发式的意图是避免预先计算的结果被多次存储和使用的情况。通常来说，这种依赖关系是对于通过显式声明手动添加的依赖关系的补充。在极少的情况下，这种启发式或带来不希望的依赖关系，此时使用`{dep=*...}`，即在依赖的名字前加前导星号，来表示详尽的依赖关系列表，覆盖不希望的依赖关系。

每条指令的活跃iname集是由用户来显式指定，或由如下规则确定的：  
**Rule 4** (活跃iname启发式)  
指令所引用的iname总是属于活跃iname集。此外，活跃的iname沿着依赖关系的传递闭包传播。

例：  
```Python
z = expr(iname) {id=insn0}
y = expr(z) {id=insn1}
z = expr(y) {id=insn2}
```
在这段代码中，由于insn1读取了`z`的值，`z`仅有语句insn0指定，故insn1依赖insn0；同样可得到，insn2依赖于insn1。此外，由于由依赖关系决定的活跃iname的传播，`iname`也属于insn1和insn2的活跃iname集。

最终得到的以上内核的循环嵌套、循环间顺序和依赖关系如下图所示：  
![Order and dependency](https://github.com/wwqqqqq/loopy-introduction/raw/master/pic/dependency.png)  

### 内核转换(Kernel Transformation)
Loo.py中包括一个转换库，可以应用到用以上数据模型表示的内核中。一般来说，这些转换函数可以通过一些指定的方法，将旧的内核转换称为新的内核。值得注意的是，Loo.py的内核实例一旦建立后，是不可修改的，故这些内核转换是没有副作用的。  

下面，举出几个常用内核转换的例子：
1. `split_name`  

内核转换`split_name`将一个iname 'OLD'，使用两个新的iname'INNER'和'OUTER'代替，`OLD = INNER + GROUP_SIZE * OUTER`。以下面的程序为例：
```Python
knl = loopy.make_kernel(
        "{ [i]: 0<=i<n}",
        "a[i] = 0"
)
knl = loopy.split_iname(knl, "i", 16)
```
得到的新内核使用C语言表示为：
```C
for (int i_outer = 0; i_outer <= (-1 + ((15 + n) / 16)); ++i_outer)
        for (int i_inner = 0; i_inner <= 15; ++i_inner)
                if ((-1 + -1 * i_inner + -16 * i_outer + n) >= 0)
                        a[i_inner + i_outer * 16] = 0.0f;
```
可以看出，为了保持结果的正确性，保留原始边界的新的边界条件被自动引入。

2. `tag_inames`

Loopy中每个iname都带有一个标记(tag)。如"unr"标记来表示iname是用于实施循环展开(loop unrolling)。`tag_inames`转换用于提供这些标记。当使用`split_iname`来建立了定长的子循环后，可以将得到的定长循环展开：
```Python
knl = loopy.make_kernel(
        "{ [i]: 0<=i<n}",
        "a[i] = 0",
        assuptions="n>=0 and n mod 4 = 0"
)
knl = loopy.split_iname(knl, "i", 4)
knl = loopy.tag_inames(knl, {"i_inner": "unr:})
```
得到的新内核使用C语言表示为：
```C
for (int i_outer = 0; i_outer <= (-1 + ((3 + n) / 4)); ++i_outer)
{
        a[0 + i_outer + 4] = 0.0f;
        a[1 + i_outer + 4] = 0.0f;
        a[2 + i_outer + 4] = 0.0f;
        a[3 + i_outer + 4] = 0.0f;
}
```
注意：如果没有对于向量长度为4的正整数倍的假设，可能会产生更加通用但效率较低的代码。

### Loo.py Kernel的数据结构

Loo.py内核是一个`LoopKernel`类。它的属性(attributes)有：

- `domains`：一个元素是`islpy.BasicSet`的类的实例的列表，每个实例表示一个循环域树(domain tree)。 
- `instructions`：一个元素为`InstructionBase`类实例(例如`Assignment`类)的列表。
- `args`：一个元素为`loopy.KernelArgument`类的列表。
- `schedule`：*None*或一个元素为`loopy.schedule.ScheduleItem`类的列表。
- `name`
- `preambles`
- `preamble_generators`
- `assumptions`：一个`islpy.BasicSet`类的参数域。
- `local_sizes`
- `temporary_variables`：一个从变量名映射到`loopy.TemporaryVariables`类的dict。
- `iname_to_tag`：一个iname(字符串类型)映射到`loopy.kernel.data.IndexTag`类型的dict。
- `function_manglers`
- `symbol_manglers`
- `substitutions`：从替换名到`SubstitutionRule`类对象的映射。
- `iname_slab_increments`：一个inames映射到`(lower_incr, upper_incr)`二元组的dict，这个二元组被用来在执行过程中产生条件较少的'bulk'块。
- `loop_priority`：内核约束的优先级的frozenset。每一个这样的约束都是一个inames的元组。元组中出现较早的iname会被更早地调度。仅用于具有非并行实现标记的iname。
- `silenced_warning`
- `applied_iname_rewrites`
- `cache_manager`
- `options`：`loopy.Options`类的一个实例。
- `state`：从`kernel_state`类中得到的内核状态的值。
- `target`：`loopy.TargetBase`的子类





## 参考文献

[Code Generation in the Polyhedral Model Is Easier Than You Think](https://dl.acm.org/citation.cfm?id=1025992) 

[Loo.py: transformation-based code generation for GPUs and CPUs](https://arxiv.org/abs/1405.7470)


## 相关链接

[GitHub repository](https://github.com/01-Loopy/loo.py-intro)

[项目简介、分工以及进展记录](https://github.com/01-Loopy/2017fall-student-teamworks/blob/master/01-loopy.md)